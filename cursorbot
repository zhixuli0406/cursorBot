#!/usr/bin/env python3
"""
CursorBot CLI Tool

Usage:
    cursorbot status          - Show system status
    cursorbot doctor          - Run diagnostics
    cursorbot start           - Start the bot
    cursorbot tui             - Launch Terminal User Interface
    cursorbot chat            - Interactive chat in terminal
    cursorbot config          - Show configuration
    cursorbot logs            - Show recent logs
    cursorbot sessions        - List active sessions
    cursorbot message         - Send message to user
    cursorbot broadcast       - Broadcast to all users
    cursorbot reset           - Reset bot data
    cursorbot version         - Show version
"""

import argparse
import asyncio
import os
import sys
from pathlib import Path

# Add src to path
sys.path.insert(0, str(Path(__file__).parent))


def cmd_status(args):
    """Show system status."""
    print("CursorBot Status")
    print("=" * 40)
    
    # Check environment
    env_vars = [
        ("TELEGRAM_BOT_TOKEN", "Telegram Bot"),
        ("CURSOR_API_KEY", "Cursor API"),
        ("OPENAI_API_KEY", "OpenAI"),
        ("ANTHROPIC_API_KEY", "Anthropic"),
        ("GOOGLE_GENERATIVE_AI_API_KEY", "Google Gemini"),
        ("OPENROUTER_API_KEY", "OpenRouter"),
        ("DISCORD_BOT_TOKEN", "Discord Bot"),
    ]
    
    print("\nConfiguration Status:")
    for var, name in env_vars:
        value = os.getenv(var)
        status = "✓ Configured" if value else "✗ Not set"
        print(f"  {name:.<25} {status}")
    
    # Check Python version
    py_version = f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}"
    print(f"\nPython Version: {py_version}")
    
    # Check if running
    pid_file = Path("data/cursorbot.pid")
    if pid_file.exists():
        pid = pid_file.read_text().strip()
        print(f"Bot PID: {pid}")
    else:
        print("Bot Status: Not running")


def cmd_doctor(args):
    """Run diagnostics."""
    print("Running diagnostics...")
    print("=" * 40)
    
    async def run_diagnostics():
        try:
            from src.core.doctor import run_diagnostics
            report = await run_diagnostics()
            print(report.to_text())
        except ImportError as e:
            print(f"Error: Could not import diagnostics module: {e}")
            print("Make sure you're in the project directory.")
    
    asyncio.run(run_diagnostics())


def cmd_start(args):
    """Start the bot."""
    print("Starting CursorBot...")
    
    # Check if already running
    pid_file = Path("data/cursorbot.pid")
    if pid_file.exists():
        pid = pid_file.read_text().strip()
        print(f"Bot may already be running (PID: {pid})")
        if not args.force:
            print("Use --force to start anyway")
            return
    
    # Import and run
    try:
        from src.main import main
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nBot stopped")
    except Exception as e:
        print(f"Error starting bot: {e}")


def cmd_config(args):
    """Show configuration."""
    print("CursorBot Configuration")
    print("=" * 40)
    
    # Load .env if exists
    env_file = Path(".env")
    if env_file.exists():
        print(f"Config file: {env_file.absolute()}")
        print("\nConfigured variables:")
        
        with open(env_file) as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#") and "=" in line:
                    key = line.split("=")[0]
                    # Mask sensitive values
                    if any(x in key for x in ["KEY", "TOKEN", "SECRET", "PASSWORD"]):
                        print(f"  {key} = ****")
                    else:
                        print(f"  {line}")
    else:
        print("No .env file found")
        print("Copy env.example to .env and configure it")


def cmd_logs(args):
    """Show recent logs."""
    log_file = Path(os.getenv("LOG_FILE_PATH", "logs/cursorbot.log"))
    
    if not log_file.exists():
        print(f"Log file not found: {log_file}")
        return
    
    lines = args.lines or 50
    
    try:
        with open(log_file) as f:
            all_lines = f.readlines()
            recent = all_lines[-lines:]
            
        print(f"Last {len(recent)} log entries:")
        print("=" * 40)
        for line in recent:
            print(line.rstrip())
    except Exception as e:
        print(f"Error reading logs: {e}")


def cmd_sessions(args):
    """List active sessions."""
    print("Active Sessions")
    print("=" * 40)
    
    async def show_sessions():
        try:
            from src.core.context import get_context_manager
            manager = get_context_manager()
            stats = manager.get_session_stats()
            
            print(f"Total sessions: {stats['total_sessions']}")
            print(f"\nBy chat type:")
            for ct, count in stats.get("by_chat_type", {}).items():
                print(f"  {ct}: {count}")
            
            print(f"\nBy status:")
            for status, count in stats.get("by_status", {}).items():
                print(f"  {status}: {count}")
                
        except Exception as e:
            print(f"Could not get session info: {e}")
    
    asyncio.run(show_sessions())


def cmd_version(args):
    """Show version."""
    print("CursorBot v0.3.0")
    print("https://github.com/your-repo/cursorBot")


def cmd_tui(args):
    """Launch Terminal User Interface."""
    print("Starting CursorBot TUI...")
    print("=" * 40)
    
    try:
        from src.cli.tui import run_tui
        asyncio.run(run_tui())
    except ImportError as e:
        print(f"Error: Could not import TUI module: {e}")
        print("\nTry installing rich for better experience:")
        print("  pip install rich")
    except KeyboardInterrupt:
        print("\nTUI closed.")
    except Exception as e:
        print(f"Error running TUI: {e}")


def cmd_chat(args):
    """Interactive chat in terminal."""
    model = args.model if hasattr(args, 'model') and args.model else None
    
    print("CursorBot Interactive Chat")
    print("=" * 40)
    print("Type your message and press Enter. Commands: /help, /quit")
    print()
    
    async def chat_loop():
        try:
            from src.core.llm_providers import get_llm_manager
            from src.cursor.cli_agent import get_cli_agent, is_cli_available
            
            manager = get_llm_manager()
            cli = get_cli_agent() if is_cli_available() else None
            
            if model and cli:
                cli.set_user_model("cli_user", model)
                print(f"Using model: {model}")
            
            while True:
                try:
                    user_input = input("\n\033[32mYou:\033[0m ")
                except EOFError:
                    break
                
                if not user_input.strip():
                    continue
                
                if user_input.strip().lower() in ["/quit", "/exit", "/q"]:
                    print("Goodbye!")
                    break
                
                if user_input.strip().lower() == "/help":
                    print("\nCommands:")
                    print("  /help  - Show this help")
                    print("  /quit  - Exit chat")
                    print("  /model - Show current model")
                    continue
                
                if user_input.strip().lower() == "/model":
                    if cli:
                        current = cli.get_user_model("cli_user") or "auto"
                        print(f"Current model: {current}")
                    continue
                
                # Get response
                print("\n\033[36mCursorBot:\033[0m ", end="", flush=True)
                
                try:
                    if cli:
                        result = await cli.run(
                            prompt=user_input,
                            user_id="cli_user",
                        )
                        print(result.output if result.success else f"Error: {result.error}")
                    else:
                        response = await manager.chat(
                            message=user_input,
                            user_id="cli_user",
                        )
                        print(response)
                except Exception as e:
                    print(f"Error: {e}")
                    
        except ImportError as e:
            print(f"Error: Could not import required modules: {e}")
    
    try:
        asyncio.run(chat_loop())
    except KeyboardInterrupt:
        print("\nChat closed.")


def cmd_message(args):
    """Send message to a user."""
    user_id = args.user_id
    text = args.text
    
    if not user_id or not text:
        print("Error: --user-id and --text are required")
        return
    
    async def send_message():
        try:
            import httpx
            
            api_port = os.getenv("API_PORT", "8000")
            api_url = f"http://localhost:{api_port}/api/message"
            
            async with httpx.AsyncClient() as client:
                response = await client.post(api_url, json={
                    "user_id": user_id,
                    "text": text,
                })
                
                if response.status_code == 200:
                    print(f"✓ Message sent to user {user_id}")
                else:
                    print(f"✗ Failed to send message: {response.text}")
                    
        except httpx.ConnectError:
            print("Error: Could not connect to API server")
            print("Make sure the bot is running with API enabled")
        except Exception as e:
            print(f"Error: {e}")
    
    asyncio.run(send_message())


def cmd_broadcast(args):
    """Broadcast message to all users."""
    text = args.text
    
    if not text:
        print("Error: --text is required")
        return
    
    async def send_broadcast():
        try:
            import httpx
            
            api_port = os.getenv("API_PORT", "8000")
            api_url = f"http://localhost:{api_port}/api/broadcast"
            
            async with httpx.AsyncClient() as client:
                response = await client.post(api_url, json={
                    "message": text,
                    "parse_mode": "HTML" if args.html else None,
                })
                
                if response.status_code == 200:
                    result = response.json()
                    print(f"✓ Broadcast sent")
                    print(f"  Success: {result.get('success_count', 0)}")
                    print(f"  Failed: {result.get('failed_count', 0)}")
                else:
                    print(f"✗ Failed to broadcast: {response.text}")
                    
        except httpx.ConnectError:
            print("Error: Could not connect to API server")
            print("Make sure the bot is running with API enabled")
        except Exception as e:
            print(f"Error: {e}")
    
    asyncio.run(send_broadcast())


def cmd_reset(args):
    """Reset bot data."""
    if not args.confirm:
        print("Warning: This will delete all bot data!")
        print("Use --confirm to proceed")
        return
    
    import shutil
    
    # Data directories to reset
    data_dirs = [
        Path("data"),
        Path("logs"),
    ]
    
    # Specific files to keep
    keep_files = [".env", "env.example"]
    
    print("Resetting CursorBot data...")
    
    for dir_path in data_dirs:
        if dir_path.exists():
            try:
                shutil.rmtree(dir_path)
                print(f"  ✓ Deleted {dir_path}")
            except Exception as e:
                print(f"  ✗ Failed to delete {dir_path}: {e}")
    
    # Clear sessions
    async def clear_sessions():
        try:
            from src.core.context import get_context_manager
            manager = get_context_manager()
            manager._contexts.clear()
            print("  ✓ Cleared all sessions")
        except Exception:
            pass
    
    asyncio.run(clear_sessions())
    
    print("\n✓ Reset complete")
    print("Restart the bot to apply changes")


def cmd_usage(args):
    """Show usage statistics."""
    print("CursorBot Usage Statistics")
    print("=" * 40)
    
    async def show_usage():
        try:
            from src.core.llm_providers import get_llm_manager
            manager = get_llm_manager()
            stats = manager.get_usage_stats()
            
            print(f"\nTotal API Calls: {stats.get('total_calls', 0)}")
            print(f"\nBy Provider:")
            for provider, count in stats.get('by_provider', {}).items():
                print(f"  {provider}: {count}")
            
            print(f"\nBy User:")
            for user_id, count in list(stats.get('by_user', {}).items())[:10]:
                print(f"  User {user_id}: {count}")
                
        except Exception as e:
            print(f"Could not get usage stats: {e}")
    
    asyncio.run(show_usage())


def cmd_onboard(args):
    """Interactive onboarding setup."""
    print("=" * 50)
    print("  Welcome to CursorBot Setup Wizard")
    print("=" * 50)
    print()
    
    env_file = Path(".env")
    env_content = {}
    
    # Load existing .env if exists
    if env_file.exists():
        print("Found existing .env file. We'll update it.\n")
        with open(env_file) as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#") and "=" in line:
                    key, value = line.split("=", 1)
                    env_content[key] = value
    
    # Step 1: Telegram Bot
    print("Step 1: Telegram Bot Configuration")
    print("-" * 40)
    current = env_content.get("TELEGRAM_BOT_TOKEN", "")
    if current:
        print(f"Current: {current[:10]}...{current[-5:]}")
        update = input("Update? (y/N): ").strip().lower()
        if update == "y":
            token = input("Enter Telegram Bot Token: ").strip()
            if token:
                env_content["TELEGRAM_BOT_TOKEN"] = token
    else:
        print("Get your bot token from @BotFather on Telegram")
        token = input("Enter Telegram Bot Token: ").strip()
        if token:
            env_content["TELEGRAM_BOT_TOKEN"] = token
    
    # Step 2: Allowed Users
    print("\nStep 2: Allowed Users")
    print("-" * 40)
    current = env_content.get("TELEGRAM_ALLOWED_USERS", "")
    if current:
        print(f"Current: {current}")
    print("Get your user ID from @userinfobot on Telegram")
    users = input("Enter allowed user IDs (comma-separated): ").strip()
    if users:
        env_content["TELEGRAM_ALLOWED_USERS"] = users
    
    # Step 3: AI Provider
    print("\nStep 3: AI Provider Configuration")
    print("-" * 40)
    print("Choose your primary AI provider:")
    print("  1. OpenAI (GPT-4)")
    print("  2. Anthropic (Claude)")
    print("  3. Google (Gemini)")
    print("  4. OpenRouter (Multiple providers)")
    print("  5. Ollama (Local)")
    
    choice = input("Enter choice (1-5): ").strip()
    
    if choice == "1":
        key = input("Enter OpenAI API Key: ").strip()
        if key:
            env_content["OPENAI_API_KEY"] = key
    elif choice == "2":
        key = input("Enter Anthropic API Key: ").strip()
        if key:
            env_content["ANTHROPIC_API_KEY"] = key
    elif choice == "3":
        key = input("Enter Google AI API Key: ").strip()
        if key:
            env_content["GOOGLE_GENERATIVE_AI_API_KEY"] = key
    elif choice == "4":
        key = input("Enter OpenRouter API Key: ").strip()
        if key:
            env_content["OPENROUTER_API_KEY"] = key
    elif choice == "5":
        env_content["OLLAMA_ENABLED"] = "true"
        host = input("Enter Ollama host (default: http://localhost:11434): ").strip()
        if host:
            env_content["OLLAMA_HOST"] = host
    
    # Step 4: Optional - Cursor Background Agent
    print("\nStep 4: Cursor Background Agent (Optional)")
    print("-" * 40)
    print("This enables AI-powered coding assistance")
    enable = input("Enable Background Agent? (y/N): ").strip().lower()
    if enable == "y":
        env_content["BACKGROUND_AGENT_ENABLED"] = "true"
        key = input("Enter Cursor API Key (if any): ").strip()
        if key:
            env_content["CURSOR_API_KEY"] = key
    
    # Save .env file
    print("\n" + "=" * 50)
    print("Saving configuration...")
    
    with open(env_file, "w") as f:
        f.write("# CursorBot Configuration\n")
        f.write("# Generated by cursorbot onboard\n\n")
        
        for key, value in env_content.items():
            f.write(f"{key}={value}\n")
    
    print("✓ Configuration saved to .env")
    print("\nNext steps:")
    print("  1. Run: ./cursorbot doctor")
    print("  2. Run: ./cursorbot start")
    print()


def cmd_dashboard(args):
    """Show CLI dashboard."""
    import time
    
    def clear_screen():
        os.system('cls' if os.name == 'nt' else 'clear')
    
    def draw_dashboard():
        clear_screen()
        print("=" * 60)
        print("  CursorBot Dashboard")
        print("=" * 60)
        
        # System info
        print("\n[System Info]")
        py_version = f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}"
        print(f"  Python: {py_version}")
        
        try:
            import psutil
            cpu = psutil.cpu_percent()
            mem = psutil.virtual_memory()
            print(f"  CPU: {cpu}%")
            print(f"  Memory: {mem.percent}% ({mem.available / 1024**3:.1f} GB free)")
        except ImportError:
            print("  (Install psutil for system metrics)")
        
        # Configuration
        print("\n[Configuration]")
        configs = [
            ("Telegram", bool(os.getenv("TELEGRAM_BOT_TOKEN"))),
            ("OpenAI", bool(os.getenv("OPENAI_API_KEY"))),
            ("Anthropic", bool(os.getenv("ANTHROPIC_API_KEY"))),
            ("Google", bool(os.getenv("GOOGLE_GENERATIVE_AI_API_KEY"))),
            ("Discord", bool(os.getenv("DISCORD_BOT_TOKEN"))),
        ]
        for name, configured in configs:
            status = "✓" if configured else "✗"
            print(f"  {status} {name}")
        
        # Sessions (async)
        print("\n[Sessions]")
        try:
            # Try to load session stats synchronously
            from src.core.context import get_context_manager
            manager = get_context_manager()
            stats = manager.get_session_stats()
            print(f"  Total: {stats['total_sessions']}")
            print(f"  Active: {stats['by_status'].get('active', 0)}")
        except Exception:
            print("  (Bot not running)")
        
        # Help
        print("\n" + "-" * 60)
        print("Press Ctrl+C to exit | Refresh: 5s")
    
    if args.once:
        draw_dashboard()
        return
    
    try:
        while True:
            draw_dashboard()
            time.sleep(5)
    except KeyboardInterrupt:
        print("\nDashboard closed.")


def main():
    parser = argparse.ArgumentParser(
        description="CursorBot CLI Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # status
    subparsers.add_parser("status", help="Show system status")
    
    # doctor
    subparsers.add_parser("doctor", help="Run diagnostics")
    
    # start
    start_parser = subparsers.add_parser("start", help="Start the bot")
    start_parser.add_argument("--force", action="store_true", help="Force start")
    
    # config
    subparsers.add_parser("config", help="Show configuration")
    
    # logs
    logs_parser = subparsers.add_parser("logs", help="Show recent logs")
    logs_parser.add_argument("-n", "--lines", type=int, default=50, help="Number of lines")
    
    # sessions
    subparsers.add_parser("sessions", help="List active sessions")
    
    # message
    message_parser = subparsers.add_parser("message", help="Send message to user")
    message_parser.add_argument("--user-id", type=int, required=True, help="Target user ID")
    message_parser.add_argument("--text", required=True, help="Message text")
    
    # broadcast
    broadcast_parser = subparsers.add_parser("broadcast", help="Broadcast to all users")
    broadcast_parser.add_argument("--text", required=True, help="Message text")
    broadcast_parser.add_argument("--html", action="store_true", help="Parse as HTML")
    
    # reset
    reset_parser = subparsers.add_parser("reset", help="Reset bot data")
    reset_parser.add_argument("--confirm", action="store_true", help="Confirm reset")
    
    # usage
    subparsers.add_parser("usage", help="Show usage statistics")
    
    # onboard
    subparsers.add_parser("onboard", help="Interactive setup wizard")
    
    # dashboard
    dashboard_parser = subparsers.add_parser("dashboard", help="Show CLI dashboard")
    dashboard_parser.add_argument("--once", action="store_true", help="Show once and exit")
    
    # tui
    subparsers.add_parser("tui", help="Launch Terminal User Interface")
    
    # chat
    chat_parser = subparsers.add_parser("chat", help="Interactive chat in terminal")
    chat_parser.add_argument("--model", help="AI model to use")
    
    # version
    subparsers.add_parser("version", help="Show version")
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    # Load .env
    from dotenv import load_dotenv
    load_dotenv()
    
    # Run command
    commands = {
        "status": cmd_status,
        "doctor": cmd_doctor,
        "start": cmd_start,
        "config": cmd_config,
        "logs": cmd_logs,
        "sessions": cmd_sessions,
        "message": cmd_message,
        "broadcast": cmd_broadcast,
        "reset": cmd_reset,
        "usage": cmd_usage,
        "onboard": cmd_onboard,
        "dashboard": cmd_dashboard,
        "tui": cmd_tui,
        "chat": cmd_chat,
        "version": cmd_version,
    }
    
    if args.command in commands:
        commands[args.command](args)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
