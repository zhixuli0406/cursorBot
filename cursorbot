#!/usr/bin/env python3
"""
CursorBot CLI Tool

Usage:
    cursorbot status          - Show system status
    cursorbot doctor          - Run diagnostics
    cursorbot start           - Start the bot
    cursorbot config          - Show configuration
    cursorbot logs            - Show recent logs
    cursorbot sessions        - List active sessions
    cursorbot message         - Send message to user
    cursorbot broadcast       - Broadcast to all users
    cursorbot reset           - Reset bot data
    cursorbot version         - Show version
"""

import argparse
import asyncio
import os
import sys
from pathlib import Path

# Add src to path
sys.path.insert(0, str(Path(__file__).parent))


def cmd_status(args):
    """Show system status."""
    print("CursorBot Status")
    print("=" * 40)
    
    # Check environment
    env_vars = [
        ("TELEGRAM_BOT_TOKEN", "Telegram Bot"),
        ("CURSOR_API_KEY", "Cursor API"),
        ("OPENAI_API_KEY", "OpenAI"),
        ("ANTHROPIC_API_KEY", "Anthropic"),
        ("GOOGLE_GENERATIVE_AI_API_KEY", "Google Gemini"),
        ("OPENROUTER_API_KEY", "OpenRouter"),
        ("DISCORD_BOT_TOKEN", "Discord Bot"),
    ]
    
    print("\nConfiguration Status:")
    for var, name in env_vars:
        value = os.getenv(var)
        status = "✓ Configured" if value else "✗ Not set"
        print(f"  {name:.<25} {status}")
    
    # Check Python version
    py_version = f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}"
    print(f"\nPython Version: {py_version}")
    
    # Check if running
    pid_file = Path("data/cursorbot.pid")
    if pid_file.exists():
        pid = pid_file.read_text().strip()
        print(f"Bot PID: {pid}")
    else:
        print("Bot Status: Not running")


def cmd_doctor(args):
    """Run diagnostics."""
    print("Running diagnostics...")
    print("=" * 40)
    
    async def run_diagnostics():
        try:
            from src.core.doctor import run_diagnostics
            report = await run_diagnostics()
            print(report.to_text())
        except ImportError as e:
            print(f"Error: Could not import diagnostics module: {e}")
            print("Make sure you're in the project directory.")
    
    asyncio.run(run_diagnostics())


def cmd_start(args):
    """Start the bot."""
    print("Starting CursorBot...")
    
    # Check if already running
    pid_file = Path("data/cursorbot.pid")
    if pid_file.exists():
        pid = pid_file.read_text().strip()
        print(f"Bot may already be running (PID: {pid})")
        if not args.force:
            print("Use --force to start anyway")
            return
    
    # Import and run
    try:
        from src.main import main
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nBot stopped")
    except Exception as e:
        print(f"Error starting bot: {e}")


def cmd_config(args):
    """Show configuration."""
    print("CursorBot Configuration")
    print("=" * 40)
    
    # Load .env if exists
    env_file = Path(".env")
    if env_file.exists():
        print(f"Config file: {env_file.absolute()}")
        print("\nConfigured variables:")
        
        with open(env_file) as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#") and "=" in line:
                    key = line.split("=")[0]
                    # Mask sensitive values
                    if any(x in key for x in ["KEY", "TOKEN", "SECRET", "PASSWORD"]):
                        print(f"  {key} = ****")
                    else:
                        print(f"  {line}")
    else:
        print("No .env file found")
        print("Copy env.example to .env and configure it")


def cmd_logs(args):
    """Show recent logs."""
    log_file = Path(os.getenv("LOG_FILE_PATH", "logs/cursorbot.log"))
    
    if not log_file.exists():
        print(f"Log file not found: {log_file}")
        return
    
    lines = args.lines or 50
    
    try:
        with open(log_file) as f:
            all_lines = f.readlines()
            recent = all_lines[-lines:]
            
        print(f"Last {len(recent)} log entries:")
        print("=" * 40)
        for line in recent:
            print(line.rstrip())
    except Exception as e:
        print(f"Error reading logs: {e}")


def cmd_sessions(args):
    """List active sessions."""
    print("Active Sessions")
    print("=" * 40)
    
    async def show_sessions():
        try:
            from src.core.context import get_context_manager
            manager = get_context_manager()
            stats = manager.get_session_stats()
            
            print(f"Total sessions: {stats['total_sessions']}")
            print(f"\nBy chat type:")
            for ct, count in stats.get("by_chat_type", {}).items():
                print(f"  {ct}: {count}")
            
            print(f"\nBy status:")
            for status, count in stats.get("by_status", {}).items():
                print(f"  {status}: {count}")
                
        except Exception as e:
            print(f"Could not get session info: {e}")
    
    asyncio.run(show_sessions())


def cmd_version(args):
    """Show version."""
    print("CursorBot v0.3.0")
    print("https://github.com/your-repo/cursorBot")


def cmd_message(args):
    """Send message to a user."""
    user_id = args.user_id
    text = args.text
    
    if not user_id or not text:
        print("Error: --user-id and --text are required")
        return
    
    async def send_message():
        try:
            import httpx
            
            api_port = os.getenv("API_PORT", "8000")
            api_url = f"http://localhost:{api_port}/api/message"
            
            async with httpx.AsyncClient() as client:
                response = await client.post(api_url, json={
                    "user_id": user_id,
                    "text": text,
                })
                
                if response.status_code == 200:
                    print(f"✓ Message sent to user {user_id}")
                else:
                    print(f"✗ Failed to send message: {response.text}")
                    
        except httpx.ConnectError:
            print("Error: Could not connect to API server")
            print("Make sure the bot is running with API enabled")
        except Exception as e:
            print(f"Error: {e}")
    
    asyncio.run(send_message())


def cmd_broadcast(args):
    """Broadcast message to all users."""
    text = args.text
    
    if not text:
        print("Error: --text is required")
        return
    
    async def send_broadcast():
        try:
            import httpx
            
            api_port = os.getenv("API_PORT", "8000")
            api_url = f"http://localhost:{api_port}/api/broadcast"
            
            async with httpx.AsyncClient() as client:
                response = await client.post(api_url, json={
                    "message": text,
                    "parse_mode": "HTML" if args.html else None,
                })
                
                if response.status_code == 200:
                    result = response.json()
                    print(f"✓ Broadcast sent")
                    print(f"  Success: {result.get('success_count', 0)}")
                    print(f"  Failed: {result.get('failed_count', 0)}")
                else:
                    print(f"✗ Failed to broadcast: {response.text}")
                    
        except httpx.ConnectError:
            print("Error: Could not connect to API server")
            print("Make sure the bot is running with API enabled")
        except Exception as e:
            print(f"Error: {e}")
    
    asyncio.run(send_broadcast())


def cmd_reset(args):
    """Reset bot data."""
    if not args.confirm:
        print("Warning: This will delete all bot data!")
        print("Use --confirm to proceed")
        return
    
    import shutil
    
    # Data directories to reset
    data_dirs = [
        Path("data"),
        Path("logs"),
    ]
    
    # Specific files to keep
    keep_files = [".env", "env.example"]
    
    print("Resetting CursorBot data...")
    
    for dir_path in data_dirs:
        if dir_path.exists():
            try:
                shutil.rmtree(dir_path)
                print(f"  ✓ Deleted {dir_path}")
            except Exception as e:
                print(f"  ✗ Failed to delete {dir_path}: {e}")
    
    # Clear sessions
    async def clear_sessions():
        try:
            from src.core.context import get_context_manager
            manager = get_context_manager()
            manager._contexts.clear()
            print("  ✓ Cleared all sessions")
        except Exception:
            pass
    
    asyncio.run(clear_sessions())
    
    print("\n✓ Reset complete")
    print("Restart the bot to apply changes")


def cmd_usage(args):
    """Show usage statistics."""
    print("CursorBot Usage Statistics")
    print("=" * 40)
    
    async def show_usage():
        try:
            from src.core.llm_providers import get_llm_manager
            manager = get_llm_manager()
            stats = manager.get_usage_stats()
            
            print(f"\nTotal API Calls: {stats.get('total_calls', 0)}")
            print(f"\nBy Provider:")
            for provider, count in stats.get('by_provider', {}).items():
                print(f"  {provider}: {count}")
            
            print(f"\nBy User:")
            for user_id, count in list(stats.get('by_user', {}).items())[:10]:
                print(f"  User {user_id}: {count}")
                
        except Exception as e:
            print(f"Could not get usage stats: {e}")
    
    asyncio.run(show_usage())


def main():
    parser = argparse.ArgumentParser(
        description="CursorBot CLI Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # status
    subparsers.add_parser("status", help="Show system status")
    
    # doctor
    subparsers.add_parser("doctor", help="Run diagnostics")
    
    # start
    start_parser = subparsers.add_parser("start", help="Start the bot")
    start_parser.add_argument("--force", action="store_true", help="Force start")
    
    # config
    subparsers.add_parser("config", help="Show configuration")
    
    # logs
    logs_parser = subparsers.add_parser("logs", help="Show recent logs")
    logs_parser.add_argument("-n", "--lines", type=int, default=50, help="Number of lines")
    
    # sessions
    subparsers.add_parser("sessions", help="List active sessions")
    
    # message
    message_parser = subparsers.add_parser("message", help="Send message to user")
    message_parser.add_argument("--user-id", type=int, required=True, help="Target user ID")
    message_parser.add_argument("--text", required=True, help="Message text")
    
    # broadcast
    broadcast_parser = subparsers.add_parser("broadcast", help="Broadcast to all users")
    broadcast_parser.add_argument("--text", required=True, help="Message text")
    broadcast_parser.add_argument("--html", action="store_true", help="Parse as HTML")
    
    # reset
    reset_parser = subparsers.add_parser("reset", help="Reset bot data")
    reset_parser.add_argument("--confirm", action="store_true", help="Confirm reset")
    
    # usage
    subparsers.add_parser("usage", help="Show usage statistics")
    
    # version
    subparsers.add_parser("version", help="Show version")
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    # Load .env
    from dotenv import load_dotenv
    load_dotenv()
    
    # Run command
    commands = {
        "status": cmd_status,
        "doctor": cmd_doctor,
        "start": cmd_start,
        "config": cmd_config,
        "logs": cmd_logs,
        "sessions": cmd_sessions,
        "message": cmd_message,
        "broadcast": cmd_broadcast,
        "reset": cmd_reset,
        "usage": cmd_usage,
        "version": cmd_version,
    }
    
    if args.command in commands:
        commands[args.command](args)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
